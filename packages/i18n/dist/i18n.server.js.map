{"version":3,"sources":["../src/i18n.server.ts"],"names":["createInstance","resourcesToBackend","resolve","initReactI18next"],"mappings":"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","file":"i18n.server.js","sourcesContent":["import { type InitOptions, createInstance, type i18n } from 'i18next';\nimport resourcesToBackend from 'i18next-resources-to-backend';\nimport { initReactI18next } from 'react-i18next/initReactI18next';\n\n/**\n * Initialize the i18n instance on the server.\n * This is useful for RSC and SSR.\n * @param settings - the i18n settings\n * @param resolver - a function that resolves the i18n resources\n */\nexport async function initializeServerI18n(\n  settings: InitOptions,\n  resolver: (language: string, namespace: string) => Promise<object>\n): Promise<i18n> {\n  const i18nInstance = createInstance();\n  const loadedNamespaces = new Set<string>();\n\n  await new Promise((resolve) => {\n    void i18nInstance\n      .use(\n        resourcesToBackend(async (language, namespace, callback) => {\n          try {\n            const data = await resolver(language, namespace);\n            loadedNamespaces.add(namespace);\n\n            return callback(null, data);\n          } catch (error) {\n            console.log(\n              `Error loading i18n file: locales/${language}/${namespace}.json`,\n              error\n            );\n\n            return callback(null, {});\n          }\n        })\n      )\n      .use({\n        type: '3rdParty',\n        init: async (i18next: typeof i18nInstance) => {\n          let iterations = 0;\n          const maxIterations = 100;\n\n          // do not bind this to the i18next instance until it's initialized\n          while (i18next.isInitializing) {\n            iterations++;\n\n            if (iterations > maxIterations) {\n              console.error(\n                `i18next is not initialized after ${maxIterations} iterations`\n              );\n\n              break;\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 1));\n          }\n\n          initReactI18next.init(i18next);\n          resolve(i18next);\n        },\n      })\n      .init(settings);\n  });\n\n  const namespaces = settings.ns as string[];\n\n  // If all namespaces are already loaded, return the i18n instance\n  if (loadedNamespaces.size === namespaces.length) {\n    return i18nInstance;\n  }\n\n  // Otherwise, wait for all namespaces to be loaded\n\n  const maxWaitTime = 0.1; // 100 milliseconds\n  const checkIntervalMs = 5; // 5 milliseconds\n\n  async function waitForNamespaces() {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < maxWaitTime) {\n      const allNamespacesLoaded = namespaces.every((ns) =>\n        loadedNamespaces.has(ns)\n      );\n\n      if (allNamespacesLoaded) {\n        return true;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, checkIntervalMs));\n    }\n\n    return false;\n  }\n\n  const success = await waitForNamespaces();\n\n  if (!success) {\n    console.warn(\n      `Not all namespaces were loaded after ${maxWaitTime}ms. Initialization may be incomplete.`\n    );\n  }\n\n  return i18nInstance;\n}\n\n/**\n * Parse the accept-language header value and return the languages that are included in the accepted languages.\n * @param languageHeaderValue\n * @param acceptedLanguages\n */\nexport function parseAcceptLanguageHeader(\n  languageHeaderValue: string | null | undefined,\n  acceptedLanguages: string[]\n): string[] {\n  // Return an empty array if the header value is not provided\n  if (!languageHeaderValue) return [];\n\n  const ignoreWildcard = true;\n\n  // Split the header value by comma and map each language to its quality value\n  return languageHeaderValue\n    .split(',')\n    .map((lang): [number, string] => {\n      const [locale, q = 'q=1'] = lang.split(';');\n\n      if (!locale) return [0, ''];\n\n      const trimmedLocale = locale.trim();\n      const numQ = Number(q.replace(/q ?=/, ''));\n\n      return [Number.isNaN(numQ) ? 0 : numQ, trimmedLocale];\n    })\n    .sort(([q1], [q2]) => q2 - q1) // Sort by quality value in descending order\n    .flatMap(([_, locale]) => {\n      // Ignore wildcard '*' if 'ignoreWildcard' is true\n      if (locale === '*' && ignoreWildcard) return [];\n\n      const languageSegment = locale.split('-')[0];\n\n      if (!languageSegment) return [];\n\n      // Return the locale if it's included in the accepted languages\n      try {\n        return acceptedLanguages.includes(languageSegment)\n          ? [languageSegment]\n          : [];\n      } catch {\n        return [];\n      }\n    });\n}\n"]}