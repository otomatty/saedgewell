{"version":3,"sources":["../src/lib/utils/cn.ts","../src/lib/utils/is-route-active.ts"],"names":["twMerge","clsx"],"mappings":";;;;;;AAIO,SAAS,MAAM,MAAsB,EAAA;AAC1C,EAAO,OAAAA,qBAAA,CAAQC,SAAK,CAAA,MAAM,CAAC,CAAA;AAC7B;;;ACNA,IAAM,SAAY,GAAA,GAAA;AASX,SAAS,aAAA,CACd,IACA,EAAA,WAAA,EACA,GACA,EAAA;AAEA,EAAA,IAAI,SAAS,WAAa,EAAA;AACxB,IAAO,OAAA,IAAA;AAAA;AAIT,EAAI,IAAA,OAAO,QAAQ,UAAY,EAAA;AAC7B,IAAO,OAAA,CAAC,IAAI,WAAW,CAAA;AAAA;AAIzB,EAAA,MAAM,aAAa,GAAO,IAAA,IAAA,GAAA,GAAA,GAAA,IAAA;AAC1B,EAAA,MAAM,YAAe,GAAA,CAAA;AACrB,EAAA,MAAM,eAAkB,GAAA,CAAA;AAGxB,EAAM,MAAA,KAAA,GAAQ,aAAa,YAAe,GAAA,eAAA;AAE1C,EAAO,OAAA,oBAAA,CAAqB,IAAM,EAAA,WAAA,EAAa,KAAK,CAAA;AACtD;AAUO,SAAS,oBACd,CAAA,UAAA,EACA,YACA,EAAA,KAAA,GAAQ,CACR,EAAA;AA/CF,EAAA,IAAA,EAAA;AAiDE,EAAA,MAAM,oBAAmB,EAAa,GAAA,YAAA,CAAA,KAAA,CAAM,GAAG,CAAE,CAAA,CAAC,MAAzB,IAA8B,GAAA,EAAA,GAAA,EAAA;AAEvD,EAAA,IAAI,CAAC,MAAO,CAAA,gBAAgB,CAAK,IAAA,MAAA,CAAO,UAAU,CAAG,EAAA;AACnD,IAAO,OAAA,KAAA;AAAA;AAGT,EAAA,IAAI,CAAC,gBAAA,CAAiB,QAAS,CAAA,UAAU,CAAG,EAAA;AAC1C,IAAO,OAAA,KAAA;AAAA;AAGT,EAAA,MAAM,cAAc,UAAe,KAAA,gBAAA;AAEnC,EAAA,IAAI,WAAa,EAAA;AACf,IAAO,OAAA,IAAA;AAAA;AAGT,EAAO,OAAA,mBAAA,CAAoB,UAAY,EAAA,gBAAA,EAAkB,KAAK,CAAA;AAChE;AAEA,SAAS,kBAAkB,IAAc,EAAA;AACvC,EAAA,OAAO,IAAK,CAAA,KAAA,CAAM,GAAG,CAAA,CAAE,OAAO,OAAO,CAAA;AACvC;AAEA,SAAS,mBAAA,CACP,UACA,EAAA,YAAA,EACA,KACA,EAAA;AACA,EAAM,MAAA,QAAA,GAAW,kBAAkB,UAAU,CAAA;AAC7C,EAAM,MAAA,gBAAA,GAAmB,wBAAyB,CAAA,YAAA,EAAc,QAAQ,CAAA;AAExE,EAAA,IAAI,eAAe,YAAc,EAAA;AAC/B,IAAO,OAAA,IAAA;AAAA;AAMT,EAAO,OAAA,gBAAA,GAAmB,QAAS,CAAA,MAAA,IAAU,KAAQ,GAAA,CAAA,CAAA;AACvD;AAEA,SAAS,wBAAA,CAAyB,MAAc,QAAoB,EAAA;AAClE,EAAA,IAAI,KAAQ,GAAA,CAAA;AAEZ,EAAW,KAAA,MAAA,OAAA,IAAW,iBAAkB,CAAA,IAAI,CAAG,EAAA;AAE7C,IAAI,IAAA,QAAA,CAAS,QAAS,CAAA,OAAO,CAAG,EAAA;AAC9B,MAAS,KAAA,IAAA,CAAA;AAAA,KACJ,MAAA;AACL,MAAO,OAAA,KAAA;AAAA;AACT;AAGF,EAAO,OAAA,KAAA;AACT;AAEA,SAAS,OAAO,IAAc,EAAA;AAC5B,EAAA,OAAO,IAAS,KAAA,SAAA;AAClB","file":"chunk-XE52ECJH.js","sourcesContent":["import { clsx } from 'clsx';\nimport type { ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n","const ROOT_PATH = '/';\n\n/**\n * @name isRouteActive\n * @description A function to check if a route is active. This is used to\n * @param end\n * @param path\n * @param currentPath\n */\nexport function isRouteActive(\n  path: string,\n  currentPath: string,\n  end?: boolean | ((path: string) => boolean),\n) {\n  // if the path is the same as the current path, we return true\n  if (path === currentPath) {\n    return true;\n  }\n\n  // if the end prop is a function, we call it with the current path\n  if (typeof end === 'function') {\n    return !end(currentPath);\n  }\n\n  // otherwise - we use the evaluateIsRouteActive function\n  const defaultEnd = end ?? true;\n  const oneLevelDeep = 1;\n  const threeLevelsDeep = 3;\n\n  // how far down should segments be matched?\n  const depth = defaultEnd ? oneLevelDeep : threeLevelsDeep;\n\n  return checkIfRouteIsActive(path, currentPath, depth);\n}\n\n/**\n * @name checkIfRouteIsActive\n * @description A function to check if a route is active. This is used to\n * highlight the active link in the navigation.\n * @param targetLink - The link to check against\n * @param currentRoute - the current route\n * @param depth - how far down should segments be matched?\n */\nexport function checkIfRouteIsActive(\n  targetLink: string,\n  currentRoute: string,\n  depth = 1,\n) {\n  // we remove any eventual query param from the route's URL\n  const currentRoutePath = currentRoute.split('?')[0] ?? '';\n\n  if (!isRoot(currentRoutePath) && isRoot(targetLink)) {\n    return false;\n  }\n\n  if (!currentRoutePath.includes(targetLink)) {\n    return false;\n  }\n\n  const isSameRoute = targetLink === currentRoutePath;\n\n  if (isSameRoute) {\n    return true;\n  }\n\n  return hasMatchingSegments(targetLink, currentRoutePath, depth);\n}\n\nfunction splitIntoSegments(href: string) {\n  return href.split('/').filter(Boolean);\n}\n\nfunction hasMatchingSegments(\n  targetLink: string,\n  currentRoute: string,\n  depth: number,\n) {\n  const segments = splitIntoSegments(targetLink);\n  const matchingSegments = numberOfMatchingSegments(currentRoute, segments);\n\n  if (targetLink === currentRoute) {\n    return true;\n  }\n\n  // how far down should segments be matched?\n  // - if depth = 1 => only highlight the links of the immediate parent\n  // - if depth = 2 => for url = /account match /account/organization/members\n  return matchingSegments > segments.length - (depth - 1);\n}\n\nfunction numberOfMatchingSegments(href: string, segments: string[]) {\n  let count = 0;\n\n  for (const segment of splitIntoSegments(href)) {\n    // for as long as the segments match, keep counting + 1\n    if (segments.includes(segment)) {\n      count += 1;\n    } else {\n      return count;\n    }\n  }\n\n  return count;\n}\n\nfunction isRoot(path: string) {\n  return path === ROOT_PATH;\n}\n"]}